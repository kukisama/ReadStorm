# ReadStorm 测试工作原理说明

> 位置：`tests/` 目录
> 
> 目的：解释测试工程如何验证主程序，以及“测试通过”的含义与边界。

---

## 1) tests 目录和主项目的关系

本仓库采用典型的多项目结构：

- `src/`：主程序代码（Application / Domain / Infrastructure / Desktop）
- `tests/ReadStorm.Tests/`：测试项目（xUnit）

测试项目不是主项目代码的拷贝，而是通过 **ProjectReference（项目引用）** 直接引用主项目：

- `ReadStorm.Application`
- `ReadStorm.Domain`
- `ReadStorm.Infrastructure`

因此测试运行时，调用的是主项目编译出来的真实代码，而不是复制版本。

---

## 2) 工作原理（编译与运行链路）

### 编译阶段

1. 测试项目编译时读取 `ReadStorm.Tests.csproj`
2. 发现 `ProjectReference` 后，先编译被引用的主项目
3. 把主项目输出程序集作为依赖提供给测试项目

### 运行阶段

1. `dotnet test` 启动测试宿主（`Microsoft.NET.Test.Sdk`）
2. xUnit 发现 `[Fact]`/`[Theory]` 测试方法
3. 测试方法直接调用主项目中的类与方法
4. 断言（`Assert.*`）判断行为是否符合预期

---

## 2.1) 测试用例来源（手写 vs 自动）

当前仓库的业务测试用例以**手写**为主：

- 测试输入数据、执行步骤、断言条件通常由开发者编写
- xUnit 会自动“发现并执行”你写好的测试方法

注意区分两个“自动”：

1. **自动发现/执行（有）**：写了 `[Fact]`/`[Theory]` 后，`dotnet test` 会自动运行它们。
2. **自动生成业务用例（默认无）**：测试框架不会自动替你生成完整业务场景断言。

因此，若某个业务场景没有对应测试用例，通常就不会被直接测试（除非被其他测试路径间接覆盖）。

---

## 3) 为什么“测试通过”可以代表主程序通过

因为测试调用的是主项目真实实现，所以当测试通过时，至少可以证明：

1. **被测试到的代码路径** 在当前输入下行为正确
2. 主项目与测试项目之间的编译依赖关系是可用的
3. 回归风险较低（已覆盖的行为没有被改坏）

换句话说：

- 测试通过 = “已覆盖范围内”主程序行为通过
- 不是“全功能、全场景、全平台”100% 无问题

---

## 4) 测试通过的边界（非常重要）

测试通过不等于以下全部通过：

- 所有业务场景（可能还有未写测试的分支）
- 所有外部依赖场景（网络波动、第三方站点变化）
- 所有平台差异（Windows/macOS/Linux UI 与环境差异）
- 非功能指标（性能、内存、并发极限）

另外，**没写到的业务用例默认不会被验证**，这也是需要持续补充测试清单的原因。

所以更准确的说法是：

> 测试通过提供了“可信证据”，证明主程序在已覆盖场景下工作正常。

---

## 5) 本仓库中的测试类型（当前）

1. **单元/行为测试**
   - 关注对象级行为（如状态机转换、设置持久化逻辑）
   - 速度快，定位问题清晰

2. **轻量集成测试**
   - 例如下载管线测试中，使用 `FakeHttpMessageHandler` 模拟网络响应
   - 目标是验证多组件串联逻辑（规则解析 -> 下载 -> 导出）

3. **脚本验证（`QuickSearchTest.csx`）**
   - 更像手工/临时验证脚本
   - 通常不计入标准 CI 测试门禁

---

## 6) 推荐的质量门禁（实践建议）

建议把“主程序可交付”的最低标准定义为：

1. `dotnet build` 通过
2. `dotnet test` 通过
3. 至少 1 条关键集成测试通过（核心链路）
4. 必要时补充手工验证（UI 主流程）

这套组合比只看“能编译”更可靠。

---

## 7) 一句话总结

`tests` 目录下的测试并不是拷贝主程序，而是通过项目引用直接测试主程序真实代码；测试通过可证明“已覆盖范围”内主程序正确，但不代表未覆盖场景自动正确。
