# ReadStorm 架构审查报告

> 审查日期：2026-02-15  
> 审查范围：ReadStorm 全量代码库（`main` 分支）  
> 审查目标：功能完整性、代码规范、最佳实践、安全性、可维护性  
> 当前阶段：M1 → M1.5（下载 + 阅读一体化设计的下载器重构阶段）

---

## 目录

1. [项目总览与功能分析](#1-项目总览与功能分析)
2. [分层架构审查](#2-分层架构审查)
3. [Domain 层审查](#3-domain-层审查)
4. [Application 层审查](#4-application-层审查)
5. [Infrastructure 层审查](#5-infrastructure-层审查)
6. [Desktop/UI 层审查](#6-desktopui-层审查)
7. [Rules 层审查](#7-rules-层审查)
8. [测试覆盖审查](#8-测试覆盖审查)
9. [代码规范与最佳实践评估](#9-代码规范与最佳实践评估)
10. [安全性审查](#10-安全性审查)
11. [性能审查](#11-性能审查)
12. [功能升级与补全建议](#12-功能升级与补全建议)
13. [总结评分](#13-总结评分)

---

## 1. 项目总览与功能分析

### 1.1 项目定位

ReadStorm 是一个基于 .NET 10 + Avalonia 11 的跨平台桌面阅读器应用。当前阶段以"下载器重构"为核心，目标是将原有 Java SoNovel 的下载能力迁移至 .NET 体系，后续将扩展为"下载 + 阅读"一体化应用。

### 1.2 已实现功能

| 功能模块 | 状态 | 说明 |
|---------|------|------|
| 多书源搜索 | ✅ 已实现 | 真实规则搜索 + 全书源聚合混合模式 |
| 书源规则加载 | ✅ 已实现 | 从 JSON 文件加载书源定义 |
| 目录解析（Toc） | ✅ 已实现 | 支持分页、offset、desc 排序 |
| 章节抓取 | ✅ 已实现 | 支持分页章节、正文过滤 |
| TXT 导出 | ✅ 已实现 | UTF-8 编码，含元信息头 |
| 下载状态机 | ✅ 已实现 | Queued → Downloading → Succeeded/Failed/Cancelled |
| 设置持久化 | ✅ 已实现 | JSON 文件存储至用户目录 |
| HTTP 重试退避 | ✅ 已实现 | 3 次指数退避 |
| 诊断日志 | ✅ 已实现 | 文件日志 + 控制台输出 |
| Avalonia UI | ✅ 已实现 | 搜索/下载/设置三页签 |
| EPUB 导出 | ❌ 未实现 | 设置项存在但导出逻辑缺失 |
| 阅读器功能 | ❌ 未实现 | 计划 M2 阶段 |
| 并发下载控制 | ❌ 未实现 | `MaxConcurrency` 设置项存在但未使用 |
| 代理支持 | ❌ 未实现 | 设置项存在但 `HttpClient` 未配置代理 |

### 1.3 总体评价

代码整体**架构清晰、分层合理、现代 C# 风格运用得当**。对于一个处于 M1 阶段的项目来说，已经具备了较好的基础设施和可扩展性。以下从各维度进行详细审查。

---

## 2. 分层架构审查

### 2.1 架构概览

```
ReadStorm.Desktop (Presentation)
    ↓ 依赖
ReadStorm.Application (用例抽象)
    ↑ 被依赖          ↓ 被依赖
ReadStorm.Infrastructure (实现)
    ↓ 依赖
ReadStorm.Domain (核心模型)
ReadStorm.Rules (规则数据)
```

### 2.2 优点 ✅

1. **分层清晰**：Domain、Application、Infrastructure、Presentation 四层分离，职责边界清楚。
2. **依赖方向正确**：Infrastructure 依赖 Application 和 Domain（依赖倒置原则），Desktop 仅依赖 Application 和 Infrastructure。
3. **接口驱动**：Application 层以接口定义用例，Infrastructure 层提供实现，符合 DIP。
4. **DI 容器正确使用**：`App.axaml.cs` 中通过 `ServiceCollection` 注册，生命周期管理合理。

### 2.3 问题与建议 ⚠️

| # | 问题 | 严重度 | 说明 |
|---|------|--------|------|
| A-1 | Desktop 项目直接引用 Infrastructure | 中 | `App.axaml.cs` 中 `ConfigureServices()` 直接引用了 `HybridSearchBooksUseCase` 等具体类。建议增加一个组合根（Composition Root）模块或使用程序集扫描来隔离。当前阶段可接受，但长期应避免 Presentation 层直接依赖 Infrastructure 具体类型。 |
| A-2 | Application 层过于单薄 | 低 | 仅包含 4 个接口，无任何编排逻辑。Use Case 接口在 Infrastructure 中直接实现，缺少应用服务层的编排能力（如事务管理、跨用例协调）。 |
| A-3 | Rules 项目仅含 JSON 数据，无代码 | 低 | `ReadStorm.Rules.csproj` 仅用于承载 JSON 规则文件，无任何 C# 代码。可考虑将其作为内容包或直接嵌入资源，减少项目数量。 |
| A-4 | 缺少 Domain 事件/领域服务 | 低 | Domain 层仅有模型和枚举，缺少领域服务和领域事件定义。状态机逻辑虽内聚在 `DownloadTask` 中（好的做法），但缺乏事件通知机制。 |

---

## 3. Domain 层审查

### 3.1 文件清单

| 文件 | 行数 | 职责 |
|------|------|------|
| `AppSettings.cs` | 20 | 应用配置模型 |
| `BookSourceRule.cs` | 12 | 书源规则模型 |
| `DownloadErrorKind.cs` | 12 | 下载错误分类枚举 |
| `DownloadMode.cs` | 8 | 下载模式枚举 |
| `DownloadTask.cs` | 151 | 下载任务核心模型（含状态机） |
| `DownloadTaskStatus.cs` | 10 | 下载任务状态枚举 |
| `SearchResult.cs` | 10 | 搜索结果记录类型 |

### 3.2 优点 ✅

1. **`DownloadTask` 状态机设计优秀**：
   - `TransitionTo()` 方法通过 `IsAllowed()` 验证状态流转合法性，防止非法状态迁移。
   - 状态历史 `StateHistory` 便于调试和审计。
   - 终态（Succeeded/Failed/Cancelled）不可再转移，设计正确。
   - `Math.Clamp` 保护进度百分比在 [0, 100] 范围内。

2. **`SearchResult` 使用 `sealed record`**：不可变值对象，语义正确。

3. **枚举显式赋值**：`DownloadErrorKind` 和 `DownloadTaskStatus` 都有明确的数值赋值，利于持久化和序列化。

4. **`sealed class` 广泛使用**：所有模型类标记为 `sealed`，防止不必要的继承，有利于性能和设计意图表达。

### 3.3 问题与建议 ⚠️

| # | 问题 | 严重度 | 文件/行号 | 说明 |
|---|------|--------|-----------|------|
| D-1 | `SetField` 方法中 `CallerMemberName` 与手动传名混用 | 中 | `DownloadTask.cs:21` | `CurrentStatus` 的 setter 传入 `nameof(Status)` 而非 `nameof(CurrentStatus)`，导致 `CurrentStatus` 的 `PropertyChanged` 事件实际通知的是 `Status` 属性名。虽然功能上 `Status` 是展示属性需要被刷新，但 `CurrentStatus` 自身的变更通知丢失了。应同时通知两者。 |
| D-2 | `Error` 和 `OutputFilePath` 的 setter 为 `public` | 中 | `DownloadTask.cs:54,62` | 与其他属性使用 `private set` 不一致。领域模型的状态应由模型自身控制，外部直接 set 破坏了封装性。建议改为 `internal` 或通过方法修改。 |
| D-3 | `ErrorKind` 的 setter 为 `public` | 中 | `DownloadTask.cs:68` | 同 D-2，建议封装到 `TransitionTo(Failed, error, errorKind)` 方法中。 |
| D-4 | `AppSettings` 缺少验证逻辑 | 中 | `AppSettings.cs` | 无 `MinIntervalMs < MaxIntervalMs` 校验，无 `MaxConcurrency > 0` 校验，无 `ProxyPort` 范围校验。虽然 UI 的 `NumericUpDown` 有 Min/Max 限制，但 Domain 模型应自我保护。 |
| D-5 | `AppSettings` 使用 `class` 而非 `record` | 低 | `AppSettings.cs` | 全部属性为可读写 `{ get; set; }`，语义上更接近 DTO。若需不可变性可考虑 `record`，但当前用作双向绑定目标，`class` 也可接受。 |
| D-6 | `BookSourceRule` 缺少更多元数据 | 低 | `BookSourceRule.cs` | 仅有 `Id`、`Name`、`Url`、`SearchSupported`，缺少 `Enabled`（启用/禁用）、`Priority`（优先级）、`LastTestedAt`（最后测试时间）等运营所需字段。 |
| D-7 | `DownloadTask` 未实现 `IDisposable` | 低 | `DownloadTask.cs` | 虽然 `DownloadTask` 本身不持有非托管资源，但若未来需要关联 `CancellationTokenSource` 时需注意。 |
| D-8 | `_stateHistory` 线程安全 | 低 | `DownloadTask.cs:80` | `List<DownloadTaskStatus>` 非线程安全集合，若并发访问（如 UI 线程读取 + 后台线程写入）可能出问题。建议使用 `ConcurrentBag` 或加锁。 |

---

## 4. Application 层审查

### 4.1 文件清单

| 文件 | 行数 | 职责 |
|------|------|------|
| `IAppSettingsUseCase.cs` | 9 | 设置加载/保存接口 |
| `IDownloadBookUseCase.cs` | 10 | 下载任务执行接口 |
| `IRuleCatalogUseCase.cs` | 8 | 规则目录查询接口 |
| `ISearchBooksUseCase.cs` | 9 | 搜索接口 |

### 4.2 优点 ✅

1. **接口定义精简**：每个接口只定义核心方法，遵循接口隔离原则（ISP）。
2. **全部支持 `CancellationToken`**：异步操作均支持取消，最佳实践。
3. **返回类型设计合理**：使用 `IReadOnlyList<T>` 而非 `List<T>`，防止调用方意外修改。

### 4.3 问题与建议 ⚠️

| # | 问题 | 严重度 | 说明 |
|---|------|--------|------|
| AP-1 | 接口命名包含 `UseCase` 后缀 | 低 | 按照 Clean Architecture 惯例，接口名通常为 `I + 动词/名词`，如 `IBookSearcher`。当前 `ISearchBooksUseCase` 也可接受，但与 `UseCase` 的概念有些混淆——接口是端口，实现才是 Use Case。 |
| AP-2 | 缺少 `IBookExporter` 接口 | 中 | 导出逻辑（TXT/EPUB/PDF）当前硬编码在 `RuleBasedDownloadBookUseCase` 内部。建议抽象为独立接口，遵循单一职责。 |
| AP-3 | 缺少 `IChapterFetcher` / `ITocParser` 等细粒度接口 | 低 | 当前下载链路的所有逻辑（目录解析、章节抓取、内容清洗、导出）都在同一个实现类中（700 行）。建议拆分为多个细粒度服务接口。 |
| AP-4 | 缺少 Result/Either 类型 | 中 | 用例方法的错误处理依赖异常。建议引入 `Result<T>` 或类似的操作结果类型，让调用方能显式处理失败场景。 |
| AP-5 | `IDownloadBookUseCase.QueueAsync` 语义模糊 | 中 | 方法名为 `QueueAsync` 暗示入队即返回，但实际实现是同步等待下载完成。建议改为 `ExecuteAsync` 或真正实现队列化。 |

---

## 5. Infrastructure 层审查

### 5.1 文件清单

| 文件 | 行数 | 职责 |
|------|------|------|
| `RuleBasedDownloadBookUseCase.cs` | 700 | 核心下载引擎 |
| `RuleBasedSearchBooksUseCase.cs` | 472 | 真实搜索引擎 |
| `EmbeddedRuleCatalogUseCase.cs` | 95 | 规则加载 |
| `HybridSearchBooksUseCase.cs` | 34 | 混合搜索代理 |
| `JsonFileAppSettingsUseCase.cs` | 60 | JSON 设置持久化 |
| `InMemoryAppSettingsUseCase.cs` | 42 | 内存设置实现 |
| `RulePathResolver.cs` | 43 | 规则路径解析 |

### 5.2 `RuleBasedDownloadBookUseCase` 详细审查

#### 优点 ✅

1. **诊断日志覆盖全面**：每个关键步骤都有 trace 日志，便于排错。
2. **HTTP 重试机制完善**：3 次指数退避，覆盖 5xx 和网络异常。
3. **请求克隆机制**：`CloneRequestAsync` 避免 `HttpRequestMessage` 重复使用的问题。
4. **异常分类准确**：`Classify()` 方法将不同异常映射到 `DownloadErrorKind`，有意义。
5. **文件名安全处理**：`SanitizeFileName` 过滤非法字符。
6. **HTML 标签清洗合理**：`<br>` → `\n`、`<p>` 标签处理、多余空行压缩。

#### 问题与建议 ⚠️

| # | 问题 | 严重度 | 文件/行号 | 说明 |
|---|------|--------|-----------|------|
| I-1 | 类过大（700 行），职责过多 | 高 | 整文件 | 包含：规则加载、目录解析、章节抓取、内容清洗、TXT 导出、HTTP 通信、日志记录、错误分类。严重违反单一职责原则。建议拆分为：`TocParser`、`ChapterFetcher`、`ContentCleaner`、`TxtExporter`、`HttpRetryHandler`。 |
| I-2 | 硬编码的下载限制 | 中 | `DownloadBookUseCase.cs:215-219` | `FullBook` 限制 80 章、`LatestN` 限制 20 章、`Range` 限制 40 章——全部硬编码。应作为配置项或由用户在 UI 中指定。 |
| I-3 | `LogFileLock` 使用 `Lock` 但日志写入在异步上下文 | 中 | `DownloadBookUseCase.cs:14,609-623` | `AppendDiagnosticLog` 使用同步 `File.AppendAllText`，在 `lock` 内执行 I/O，可能阻塞线程池线程。建议改用异步日志队列或 `SemaphoreSlim`。 |
| I-4 | `HttpClient` 在构造函数中直接创建 | 中 | `DownloadBookUseCase.cs:534-543` | 未使用 `IHttpClientFactory`，可能导致 socket 耗尽问题。虽然当前作为 `Singleton` 注册缓解了部分问题，但最佳实践是使用 `HttpClientFactory`。 |
| I-5 | `Console.WriteLine` 残留 | 低 | `DownloadBookUseCase.cs:617` | WinExe 项目中 `Console.WriteLine` 无效。应使用结构化日志（如 `Serilog`）替代。 |
| I-6 | 正则表达式未预编译 | 低 | `DownloadBookUseCase.cs:332,366,420` | `Regex.Replace` 和 `Regex.Match` 使用运行时编译的正则，频繁调用时有性能开销。建议使用 `[GeneratedRegex]` 源生成器或 `static readonly Regex`。 |
| I-7 | `catch` 块空体吞异常 | 中 | `DownloadBookUseCase.cs:335-339,619-622` | 虽有注释说明意图，但完全吞掉异常不利于排查问题。建议至少记录 `Debug` 级别日志。 |
| I-8 | 重复的 `RuleFileDto` 定义 | 中 | 两个文件 | `RuleBasedDownloadBookUseCase` 和 `RuleBasedSearchBooksUseCase` 各自定义了 `RuleFileDto` 内部类，字段不完全一致。应统一为共享 DTO。 |
| I-9 | 重复的 `NormalizeSelector` / `ResolveUrl` / `CloneRequestAsync` | 高 | 两个文件 | 搜索和下载用例中完全重复实现了这些工具方法。严重违反 DRY 原则，应提取到共享帮助类。 |
| I-10 | 无请求间隔控制 | 中 | 整文件 | `AppSettings` 中有 `MinIntervalMs` 和 `MaxIntervalMs`，但下载过程中未使用。连续请求可能触发目标站点反爬机制。 |

### 5.3 `RuleBasedSearchBooksUseCase` 详细审查

#### 优点 ✅

1. **搜索结果去重逻辑合理**：按 `Title|Author` 去重，限制最多 50 条。
2. **支持 POST 搜索**：`BuildFormData` 可解析 JSON-like 表单模板。
3. **`LinkedHashSet` 自定义实现**：保证插入顺序的去重集合，实用。

#### 问题与建议 ⚠️

| # | 问题 | 严重度 | 说明 |
|---|------|--------|------|
| I-11 | `static readonly HttpClient` 单例 | 中 | 全局静态 `HttpClient` 的 DNS 缓存无法更新。长时间运行的桌面应用中，目标站点 IP 变化后将持续连接失败。建议使用 `SocketsHttpHandler` 配置 `PooledConnectionLifetime`。 |
| I-12 | `Classify()` 返回值被丢弃 | 低 | `catch (Exception ex) { _ = Classify(ex); return []; }` 分类结果未使用。应记录日志或返回包含错误信息的结果。 |
| I-13 | `BuildFormData` 解析不够健壮 | 低 | 按 `,` 和 `:` 分割的简易解析器，无法处理值中包含 `,` 或 `:` 的情况。应考虑使用标准 JSON 解析。 |

### 5.4 `JsonFileAppSettingsUseCase` 审查

#### 优点 ✅

1. **原子写入**：先写入 `.tmp` 文件再重命名，防止写入中断导致配置文件损坏。
2. **目录自动创建**：写入前确保目录存在。

#### 问题与建议 ⚠️

| # | 问题 | 严重度 | 说明 |
|---|------|--------|------|
| I-14 | 缺少文件锁 / 并发保护 | 低 | 多个异步调用同时 `SaveAsync` 可能产生竞态条件。建议添加 `SemaphoreSlim` 保护。 |
| I-15 | `LoadAsync` 未处理 JSON 格式错误 | 低 | 若用户手动编辑了配置文件导致 JSON 格式错误，`DeserializeAsync` 会抛异常。建议 `try-catch` 并返回默认值。 |

### 5.5 `InMemoryAppSettingsUseCase` 审查

#### 问题 ⚠️

| # | 问题 | 严重度 | 说明 |
|---|------|--------|------|
| I-16 | 属性手动复制容易遗漏 | 低 | `LoadAsync` 和 `SaveAsync` 中逐属性复制 `AppSettings`，若新增属性容易遗忘。建议使用序列化/反序列化实现深拷贝，或使用 `record` 类型的 `with` 表达式。 |

### 5.6 `RulePathResolver` 审查

#### 问题 ⚠️

| # | 问题 | 严重度 | 说明 |
|---|------|--------|------|
| I-17 | 向上遍历所有父目录 | 低 | `EnumerateParents` 会一直遍历到根目录，在深层路径下会产生大量不必要的 `Directory.Exists` 调用。建议限制搜索深度（如最多 5 级）。 |
| I-18 | 路径中包含中文硬编码 | 低 | `参考文档/novel-main/novel-main/src/main/resources/rule` 为硬编码的中文路径，与特定开发环境耦合。建议通过配置指定。 |

---

## 6. Desktop/UI 层审查

### 6.1 文件清单

| 文件 | 行数 | 职责 |
|------|------|------|
| `App.axaml` | 15 | 应用资源定义 |
| `App.axaml.cs` | 71 | DI 配置与启动 |
| `Program.cs` | 22 | 入口点 |
| `ViewLocator.cs` | 38 | ViewModel → View 映射 |
| `MainWindowViewModel.cs` | 228 | 主窗口 ViewModel |
| `ViewModelBase.cs` | 7 | ViewModel 基类 |
| `MainWindow.axaml` | 126 | 主窗口 UI 布局 |
| `MainWindow.axaml.cs` | 11 | 主窗口 code-behind |

### 6.2 `MainWindowViewModel` 详细审查

#### 优点 ✅

1. **MVVM 模式规范**：使用 `CommunityToolkit.Mvvm` 的 `[ObservableProperty]` 和 `[RelayCommand]`，代码简洁。
2. **依赖注入正确**：通过构造函数注入 4 个用例接口。
3. **异步命令**：`SearchAsync`、`QueueDownloadAsync`、`SaveSettingsAsync` 均为异步实现。
4. **搜索防重入**：`IsSearching` 标志位防止重复搜索。
5. **友好的状态消息**：中文提示覆盖了正常流程和异常场景。

#### 问题与建议 ⚠️

| # | 问题 | 严重度 | 文件/行号 | 说明 |
|---|------|--------|-----------|------|
| U-1 | 构造函数中触发异步操作 | 高 | `MainWindowViewModel.cs:32-33` | `_ = LoadSettingsAsync()` 和 `_ = LoadRuleStatsAsync()` 使用 fire-and-forget 模式。若加载失败，异常将被静默吞掉。建议使用 `CommunityToolkit.Mvvm` 的 `AsyncRelayCommand` 或在 `OnNavigatedTo` 等生命周期方法中触发。 |
| U-2 | 下载操作在 UI 线程 `await` | 高 | `MainWindowViewModel.cs:157` | `QueueDownloadAsync` 中 `await _downloadBookUseCase.QueueAsync(...)` 会阻塞 UI 线程直到下载完成（可能数分钟）。虽然 `await` 不会阻塞线程，但如果内部有同步 I/O（如 `File.AppendAllText`），仍可能导致 UI 卡顿。建议使用 `Task.Run` 将下载操作移到后台线程。 |
| U-3 | `DownloadTasks.Insert(0, task)` 非线程安全 | 中 | `MainWindowViewModel.cs:154` | `ObservableCollection` 的修改应在 UI 线程执行。当前虽在 `async` 方法中（会自动回到 UI 线程），但后续若引入真正的后台队列，需注意线程安全。 |
| U-4 | 硬编码检测 `example.com` | 中 | `MainWindowViewModel.cs:137` | 用 URL 包含 `example.com` 来判断是否为示例数据，不够健壮。应在 `SearchResult` 模型中增加 `IsMock` 属性或类似标识。 |
| U-5 | 设置属性与 `AppSettings` 模型重复 | 中 | `MainWindowViewModel.cs:64-85` | ViewModel 中逐一定义了 `DownloadPath`、`MaxConcurrency` 等属性，与 `AppSettings` 模型 1:1 对应。建议封装 `SettingsViewModel` 或直接绑定 `AppSettings` 对象（需添加 `INotifyPropertyChanged` 支持）。 |
| U-6 | 缺少 Loading 状态反馈 | 低 | `MainWindowViewModel.cs` | 下载过程中缺少明确的"正在下载"UI 反馈（如禁用按钮、显示进度条），仅依赖状态栏文字。 |
| U-7 | `SelectedSearchResult.Url` 空值风险 | 低 | `MainWindowViewModel.cs:137` | 若 `Url` 为 `null`，`.Contains()` 会抛 `NullReferenceException`。`SearchResult` 的 `Url` 是 `string`（non-nullable），但构造时可能传入空字符串。 |

### 6.3 `MainWindow.axaml` UI 审查

#### 优点 ✅

1. **FluentTheme 使用正确**：现代化外观。
2. **`DockPanel` + `TabControl` 布局合理**：顶部状态栏 + 多页签内容区。
3. **`Grid` 布局工整**：搜索页和设置页使用 `Grid` 对齐控件。
4. **`DataTemplate` 使用正确**：搜索结果和下载任务的列表模板清晰。
5. **编译绑定**：`AvaloniaUseCompiledBindingsByDefault=true` + `x:DataType` 启用编译时绑定检查。

#### 问题与建议 ⚠️

| # | 问题 | 严重度 | 说明 |
|---|------|--------|------|
| U-8 | 设计时 DataContext 使用无参构造的 ViewModel | 低 | `<vm:MainWindowViewModel/>` 在设计器中无法正常工作，因为 `MainWindowViewModel` 需要 4 个依赖参数。建议创建 `DesignTimeMainWindowViewModel` 或使用 `d:DesignInstance`。 |
| U-9 | 导出格式使用 `TextBox` 而非 `ComboBox` | 低 | 导出格式应为有限选项（txt/epub/pdf），使用下拉框更合适。 |
| U-10 | 缺少必要的 UI 反馈控件 | 中 | 无全局进度条、无 Toast/Notification 提示、无下载取消按钮。 |
| U-11 | 状态栏文字过长时无换行 | 低 | 错误信息可能很长，`TextBlock` 未设置 `TextWrapping="Wrap"`。 |

### 6.4 `App.axaml.cs` DI 配置审查

#### 问题 ⚠️

| # | 问题 | 严重度 | 说明 |
|---|------|--------|------|
| U-12 | `ServiceProvider` 需在 `Exit` 时 Dispose | ✅ 已处理 | `desktop.Exit += (_, _) => _serviceProvider?.Dispose();` 正确处理了生命周期。 |
| U-13 | `RuleBasedDownloadBookUseCase` 注册为 Singleton 但需要 `IAppSettingsUseCase` | 低 | 两者均为 Singleton，无问题。但若未来 `IAppSettingsUseCase` 改为 Scoped，将出现 Captive Dependency 问题。 |

---

## 7. Rules 层审查

### 7.1 文件清单

| 文件 | 说明 |
|------|------|
| `ReadStorm.Rules.csproj` | 空项目，仅用于承载 JSON |
| `rules/rule-1.json` | 示例书源 A |
| `rules/rule-2.json` | 示例书源 B |

### 7.2 问题与建议 ⚠️

| # | 问题 | 严重度 | 说明 |
|---|------|--------|------|
| R-1 | JSON 规则缺少 Schema 定义 | 中 | 无 JSON Schema 文件，规则格式依赖代码中的 `RuleFileDto` 内部类定义。建议创建 `rule.schema.json` 并在 JSON 文件中引用。 |
| R-2 | 示例规则缺少完整字段 | 低 | `rule-1.json` 只有 `search.url`，`rule-2.json` 连 `search` 都没有。缺少 `toc`、`chapter` 等完整示例，不利于新贡献者理解规则格式。 |
| R-3 | 规则版本控制缺失 | 低 | 规则文件无版本号字段，后续规则格式升级时难以兼容管理。 |

---

## 8. 测试覆盖审查

### 8.1 测试概览

| 测试文件 | 测试数 | 类型 |
|---------|--------|------|
| `UnitTest1.cs` | 8 | 单元/行为测试 |
| `DownloadPipelineIntegrationTests.cs` | 1 | 集成测试 |
| **总计** | **9** | |

### 8.2 测试覆盖分析

| 被测模块 | 覆盖情况 | 说明 |
|---------|---------|------|
| HybridSearchBooksUseCase | ✅ 有测试 | 1 条 |
| InMemoryAppSettingsUseCase | ✅ 有测试 | 1 条 |
| JsonFileAppSettingsUseCase | ✅ 有测试 | 1 条 |
| DownloadTask 状态机 | ✅ 有测试 | 1 条（非法流转） |
| EmbeddedRuleCatalogUseCase | ✅ 有测试 | 1 条 |
| RuleBasedDownloadBookUseCase | ⚠️ 有测试但失败 | 集成测试 1 条（当前失败） |
| RuleBasedSearchBooksUseCase | ❌ 无直接测试 | 仅通过 HybridSearch 间接覆盖 |
| MainWindowViewModel | ❌ 无测试 | ViewModel 逻辑未覆盖 |
| RulePathResolver | ❌ 无测试 | — |
| ContentCleaning 逻辑 | ❌ 无测试 | HTML → 文本提取逻辑未独立测试 |

### 8.3 问题与建议 ⚠️

| # | 问题 | 严重度 | 说明 |
|---|------|--------|------|
| T-1 | 集成测试 `DownloadPipelineIntegrationTests` 当前失败 | 高 | 章节内容提取返回空。日志显示 `chapter-fetch-empty`，说明 `ExtractTextFromContent` 在当前 HTML 夹具下未能正确提取正文。**需要修复测试或调整被测代码逻辑。** |
| T-2 | 测试文件命名不规范 | 低 | `UnitTest1.cs` 应重命名为更有意义的名称，如 `SearchUseCaseTests.cs`、`SettingsUseCaseTests.cs`、`DownloadTaskTests.cs` 等。 |
| T-3 | 测试未按被测类分文件 | 低 | 所有测试混在一个文件中，建议按被测类拆分。 |
| T-4 | ViewModel 无测试 | 中 | `MainWindowViewModel` 包含业务逻辑（如 `example.com` 检测、搜索防重入），应有单元测试覆盖。 |
| T-5 | 缺少边界条件测试 | 中 | 如：空关键词搜索、超长书名导出、非法状态流转的更多路径、`AppSettings` 极值等。 |
| T-6 | 无模拟框架使用 | 低 | 未引入 `Moq` 或 `NSubstitute`。当前主要通过 `FakeHttpMessageHandler` 与轻量测试替身应对。对于当前规模可接受，但建议后续引入。 |

---

## 9. 代码规范与最佳实践评估

### 9.1 规范遵循情况

| 规范项 | 状态 | 说明 |
|-------|------|------|
| C# 命名规范 | ✅ 优秀 | PascalCase 类名/方法名、camelCase 局部变量、`_` 前缀私有字段 |
| `sealed` 修饰符 | ✅ 优秀 | 所有不需继承的类均标记 `sealed` |
| `nullable` 启用 | ✅ 优秀 | 全项目启用 `<Nullable>enable</Nullable>` |
| `init` 属性 | ✅ 优秀 | 不可变属性使用 `init`，如 `BookSourceRule` |
| `record` 类型 | ✅ 良好 | `SearchResult` 使用 `sealed record`，语义正确 |
| 文件范围命名空间 | ✅ 优秀 | 全部使用 `namespace X;` 而非块级命名空间 |
| 集合表达式 | ✅ 优秀 | 使用 `[]` 而非 `new List<T>()` 或 `Array.Empty<T>()` |
| 模式匹配 | ✅ 优秀 | `is`、`switch` 表达式使用现代语法 |
| `ImplicitUsings` | ✅ | 全项目启用 |
| 异步方法 `Async` 后缀 | ✅ | 异步方法均以 `Async` 结尾 |
| XML 文档注释 | ⚠️ 缺失 | 公共 API 缺少 XML 注释 |
| 代码注释 | ✅ 适度 | 关键决策有中文注释说明，不过度注释 |

### 9.2 代码风格一致性

| 项目 | 一致性 | 说明 |
|------|--------|------|
| 缩进 | ✅ | 统一 4 空格 |
| 大括号 | ✅ | 统一 Allman 风格（新行大括号） |
| 字符串 | ✅ | 使用字符串插值 `$""` 和原始字符串 `"""` |
| 空值处理 | ✅ | `??`、`is null`、`is not null` 使用一致 |
| LINQ | ✅ | 方法链语法，格式化合理 |

### 9.3 最佳实践遵循

| 实践 | 状态 | 说明 |
|------|------|------|
| 依赖注入 | ✅ | 构造函数注入，单一组合根 |
| 异步编程 | ✅ | 正确使用 `async/await`，支持 `CancellationToken` |
| 不可变性 | ⚠️ 部分 | `SearchResult` 不可变，`AppSettings` 可变，`DownloadTask` 部分可变 |
| MVVM 模式 | ✅ | 正确分离 View/ViewModel |
| 错误处理 | ⚠️ 待改进 | 依赖异常，缺少 Result 类型 |
| 日志记录 | ⚠️ 待改进 | 自定义日志，未使用标准日志框架 |
| 配置管理 | ✅ | JSON 文件 + 原子写入 |
| 资源释放 | ⚠️ | `HttpClient` 管理待改进 |

---

## 10. 安全性审查

### 10.1 安全检查清单

| 检查项 | 状态 | 说明 |
|-------|------|------|
| 路径遍历防护 | ⚠️ 部分 | `SanitizeFileName` 过滤了非法文件名字符，但未验证 `DownloadPath` 是否包含路径遍历字符（如 `../`）。恶意配置可能导致文件写入到非预期目录。 |
| 正则表达式 DoS | ⚠️ 风险 | `chapter.FilterTxt` 来自规则 JSON 文件，若包含恶意正则（如 `(a+)+$`），可能导致 ReDoS。建议添加正则执行超时。 |
| HTTP 请求安全 | ⚠️ | 请求 URL 来自规则文件和搜索结果，未做 SSRF（服务端请求伪造）防护。桌面应用风险较低，但应注意不请求内网地址。 |
| 敏感信息泄露 | ✅ | 日志中未记录敏感信息。代理配置存储在用户本地目录。 |
| 输入验证 | ⚠️ | 搜索关键词未做长度限制和特殊字符过滤。 |
| 依赖安全 | ✅ | 使用的依赖包（Avalonia、AngleSharp、CommunityToolkit.Mvvm）均为知名维护良好的库。 |

### 10.2 关键安全建议

1. **正则表达式超时**：`Regex.Replace(content, chapter.FilterTxt, ...)` 应添加 `RegexOptions.None, TimeSpan.FromSeconds(2)` 超时参数。
2. **路径验证**：`ExportTxtAsync` 中应验证最终输出路径在预期下载目录内。
3. **URL 白名单**：考虑限制请求 URL 的协议（仅允许 `http/https`）和域名范围。

---

## 11. 性能审查

### 11.1 性能关注点

| 项目 | 状态 | 说明 |
|------|------|------|
| HTML 解析性能 | ⚠️ | 每次解析都新建 `HtmlParser` 实例。`AngleSharp` 的 `HtmlParser` 是轻量级的，但频繁创建仍有开销。建议复用实例。 |
| 同步日志写入 | ⚠️ | `File.AppendAllText` 在 `lock` 中执行，可能成为瓶颈。 |
| 内存使用 | ✅ | 使用 `StringBuilder` 拼接章节内容，避免字符串拼接的内存问题。 |
| 连接复用 | ✅ | `HttpClient` 作为单例，连接可复用。 |
| 集合预分配 | ✅ | `new List<string>(capacity: 256)` 等使用了容量预分配。 |
| 异步 I/O | ✅ | 文件和网络操作均使用异步方法。 |

---

## 12. 功能升级与补全建议

### 12.1 短期建议（M1.5 → M2，优先级高）

#### 12.1.1 修复已知问题

1. **修复集成测试失败**：`DownloadPipelineIntegrationTests.RuleBasedDownload_ShouldExportTxt_FromFixtureHtmlPipeline` 中章节内容提取为空。检查 `ExtractTextFromContent` 对 `<div id='content'>` 的选择器匹配逻辑。

2. **实现请求间隔控制**：利用已有的 `MinIntervalMs` / `MaxIntervalMs` 设置，在下载章节间添加随机延迟：
   ```csharp
   var delay = Random.Shared.Next(settings.MinIntervalMs, settings.MaxIntervalMs + 1);
   await Task.Delay(delay, cancellationToken);
   ```

3. **实现代理支持**：`AppSettings` 已有代理配置，但 `HttpClient` 未使用：
   ```csharp
   if (settings.ProxyEnabled)
   {
       var handler = new HttpClientHandler
       {
           Proxy = new WebProxy(settings.ProxyHost, settings.ProxyPort),
           UseProxy = true,
       };
       // 使用带 handler 的 HttpClient
   }
   ```

4. **实现并发下载**：利用 `MaxConcurrency` 配置，使用 `SemaphoreSlim` 或 `Channel<T>` 控制并发：
   ```csharp
   var semaphore = new SemaphoreSlim(settings.MaxConcurrency);
   var tasks = chapters.Select(async chapter =>
   {
       await semaphore.WaitAsync(cancellationToken);
       try { /* fetch chapter */ }
       finally { semaphore.Release(); }
   });
   await Task.WhenAll(tasks);
   ```

#### 12.1.2 代码重构

5. **拆分 `RuleBasedDownloadBookUseCase`**（700 行 → 多个类）：
   - `TocParser`：目录解析逻辑
   - `ChapterFetcher`：章节抓取逻辑
   - `ContentCleaner`：正文清洗逻辑
   - `TxtExporter` / `IBookExporter`：导出逻辑
   - `HttpRetryPolicy`：HTTP 重试策略

6. **提取共享工具类**：
   ```
   Infrastructure/Shared/
   ├── HtmlHelpers.cs          // NormalizeSelector, ResolveUrl
   ├── HttpRetryHandler.cs     // SendWithRetryAsync, CloneRequestAsync
   └── RuleFileDto.cs          // 统一规则 DTO
   ```

7. **引入 `Result<T>` 类型**：
   ```csharp
   public record Result<T>(T? Value, string? Error, bool IsSuccess)
   {
       public static Result<T> Ok(T value) => new(value, null, true);
       public static Result<T> Fail(string error) => new(default, error, false);
   }
   ```

#### 12.1.3 下载任务管理

8. **实现真正的任务队列**：
   - 使用 `Channel<DownloadTask>` 实现 Producer-Consumer 模式
   - 支持队列优先级、任务取消（`CancellationTokenSource`）
   - UI 绑定到后台任务状态

9. **实现下载任务取消**：
   - `DownloadTask` 关联 `CancellationTokenSource`
   - UI 提供"取消"按钮

10. **实现下载任务持久化**：
    - 保存到 SQLite，支持应用重启后恢复

### 12.2 中期建议（M2，阅读器一期）

#### 12.2.1 EPUB 导出

11. **实现 EPUB 导出**：
    - 引入 `EpubSharp` 或自行构建 EPUB 包
    - 复用已有的 `IBookExporter` 接口（建议先创建）
    - 支持封面、目录、章节正文

#### 12.2.2 阅读器核心

12. **TXT 阅读器**：
    - 数据模型：`Book`、`ReadingProgress`、`Bookmark`
    - 按章节索引 + 按段渲染
    - 阅读进度保存（SQLite）
    - 书架管理（最近阅读、已下载、手动导入）

13. **阅读器 UI**：
    - 阅读页：全屏阅读、翻页、字体/主题设置
    - 书架页：网格/列表切换、搜索过滤
    - 主题支持：亮色/暗色/自定义背景

#### 12.2.3 数据存储升级

14. **引入 SQLite**：
    ```
    Domain/
    ├── Entities/
    │   ├── Book.cs
    │   ├── Chapter.cs
    │   ├── ReadingProgress.cs
    │   └── Bookmark.cs
    Application/
    ├── Abstractions/
    │   ├── IBookRepository.cs
    │   └── IReadingProgressRepository.cs
    Infrastructure/
    ├── Persistence/
    │   ├── ReadStormDbContext.cs
    │   └── SqliteBookRepository.cs
    ```

### 12.3 长期建议（M3+）

#### 12.3.1 架构改进

15. **引入 `MediatR` 或事件驱动架构**：
    - 用例通过 `IMediator` 分发
    - 下载完成事件 → 自动入书架
    - 状态变更事件 → UI 通知

16. **引入 `IHttpClientFactory`**：
    - 替代手动管理 `HttpClient`
    - 支持命名客户端（搜索用、下载用）
    - 集成 Polly 弹性策略

17. **引入结构化日志（Serilog）**：
    ```csharp
    Log.Information("下载完成 {@Task}", new { task.Id, task.BookTitle, Elapsed });
    ```

#### 12.3.2 功能扩展

18. **书源管理页面**：
    - 书源启用/禁用
    - 书源可用性检测
    - 书源规则导入/导出
    - 规则编辑器

19. **下载增强**：
    - 断点续传
    - 下载历史
    - 批量下载
    - 下载速度显示

20. **内容增强**：
    - 更智能的广告过滤（基于规则 + 通用模式）
    - 章节合并/拆分
    - 内容纠错（繁简转换、标点修正）

21. **用户体验**：
    - 全局快捷键
    - 系统托盘
    - 自动更新
    - 多语言支持（i18n）

22. **CI/CD**：
    - GitHub Actions 自动构建
    - 自动测试
    - 多平台打包（Windows/macOS/Linux）
    - 自动发布到 GitHub Releases

---

## 13. 总结评分

### 13.1 各维度评分

| 维度 | 评分（5分制） | 说明 |
|------|-------------|------|
| **架构设计** | ⭐⭐⭐⭐ (4/5) | 分层清晰、依赖方向正确、接口驱动。扣分项：Application 层过薄、单个实现类过大。 |
| **代码质量** | ⭐⭐⭐⭐ (4/5) | 现代 C# 语法运用得当、命名规范、风格一致。扣分项：DRY 违反（重复代码）、部分封装性不足。 |
| **功能完整性** | ⭐⭐⭐ (3/5) | 核心下载链路已通、设置可持久化。扣分项：EPUB 未实现、并发控制未实现、代理未实现（配置项已有）。 |
| **测试覆盖** | ⭐⭐⭐ (3/5) | 关键路径有测试覆盖、集成测试方向正确。扣分项：覆盖率偏低、集成测试失败、ViewModel 无测试。 |
| **安全性** | ⭐⭐⭐ (3/5) | 基本安全措施到位。扣分项：正则 DoS 风险、路径遍历风险、缺少输入验证。 |
| **性能** | ⭐⭐⭐⭐ (4/5) | 异步 I/O、连接复用、内存管理良好。扣分项：同步日志写入、缺少并发控制。 |
| **可维护性** | ⭐⭐⭐⭐ (4/5) | 项目结构清晰、依赖管理规范、文档完善。扣分项：大类需拆分、缺少代码注释。 |
| **用户体验** | ⭐⭐⭐ (3/5) | 基础 UI 功能完整、中文本地化。扣分项：缺少进度条、取消按钮、通知提示等交互细节。 |

### 13.2 综合评价

| 项目 | 评价 |
|------|------|
| **总体评分** | **⭐⭐⭐⭐ (3.5/5)** — 优于平均水平 |
| **代码给力程度** | **给力 👍** — 架构设计和代码风格体现了较高的工程素养，分层合理、命名规范、现代 C# 特性运用得当。 |
| **最大亮点** | 状态机设计、分层架构、编译绑定、诊断日志体系 |
| **最大改进机会** | 拆分大类（SRP）、消除重复代码（DRY）、补全测试覆盖、实现已声明但未使用的配置项 |

### 13.3 优先改进路线图

```
立即修复（P0）
├── 修复集成测试失败
├── 正则表达式添加超时防护
└── DownloadTask 属性封装性改进

短期改进（P1，1-2 周）
├── 拆分 RuleBasedDownloadBookUseCase（700 行 → 多类）
├── 提取重复代码（NormalizeSelector/ResolveUrl/CloneRequestAsync）
├── 实现请求间隔控制（已有配置项）
├── 实现代理支持（已有配置项）
└── 补充 ViewModel 和边界条件测试

中期改进（P2，2-4 周）
├── 实现真正的并发下载队列
├── 实现 EPUB 导出
├── 引入 IHttpClientFactory
├── 引入结构化日志（Serilog）
└── 实现下载任务取消

长期演进（P3，M2+）
├── 阅读器核心功能
├── SQLite 数据存储
├── 书源管理页面
└── CI/CD 自动化
```

---

> **审查结论**：ReadStorm 在 M1 阶段展现了良好的架构设计能力和现代 C# 开发水平。代码整体给力，核心下载链路已打通，分层架构为后续扩展（阅读器、多格式导出）奠定了坚实基础。建议按上述优先级路线图逐步改进，在保持架构优势的同时补齐功能和质量短板。
